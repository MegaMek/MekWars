/*
 * Created on 21.05.2004
 */

/*
 * MekWars - Copyright (C) 2004 
 * 
 * Derived from MegaMekNET (http://www.sourceforge.net/projects/megameknet)
 * Original author Helge Richter (McWizard)
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 */

package client.campaign;

import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.StringTokenizer;
import java.util.TreeSet;

import client.MWClient;
import common.Army;
import common.Unit;
import common.util.TokenReader;

/**
 * Client-side representation of an Army. The CArmy has, when compared to its
 * server-side counterpart, very few functional methods, and mostly serves as a
 * holder for server data that the client needs in order to represent forces
 * graphically, load units into games, etc.
 */
public class CArmy extends Army {

    // VARS
    private MWClient mwclient;
    private TreeSet<String> legalOperations;
    private float rawForceSize = 0;

    // CONSTRUCTOR
    public CArmy() {
        super();
        legalOperations = new TreeSet<String>();
    }

    // METHODS
    /**
     * Method that fills in Army data (common.Army value), given an
     * informational String. Called from CPlayer.setArmyData() and
     * CPlayer.setData(). In both instances, the string being passed is
     * generated by the server and sent down using a PL| cmd.
     */
    public void fromString(String s, CPlayer p, String delimiter, MWClient client) {
        mwclient = client;
        StringTokenizer ST = new StringTokenizer(s, delimiter);
        setID(TokenReader.readInt(ST));
        setBV(TokenReader.readInt(ST));
        setLocked(TokenReader.readBoolean(ST));
        setName(TokenReader.readString(ST));
        setLowerLimiter(TokenReader.readInt(ST));
        setUpperLimiter(TokenReader.readInt(ST));
        int count = TokenReader.readInt(ST);
        for (int i = 0; i < count; i++) {
            CUnit u = p.getUnit(TokenReader.readInt(ST));

            // do not add units with id 0 as their id has already been replaced
            // --Torren
            if (u.getId() != 0)
                addUnit(u);
        }

        count = TokenReader.readInt(ST);
        for (int i = 0; i < count; i++) {
            int key = TokenReader.readInt(ST);
            int unit = TokenReader.readInt(ST);
            getC3Network().put(key, unit);
        }

        this.setOpForceSize(TokenReader.readFloat(ST));

        count = TokenReader.readInt(ST);
        for (int i = 0; i < count; i++) {
            int unit = TokenReader.readInt(ST);
            addCommander(unit);
        }

        boolean locked = TokenReader.readBoolean(ST);
        if (locked)
            playerLockArmy();
        else
            playerUnlockArmy();
        boolean disabled = TokenReader.readBoolean(ST);
        if (disabled)
            disableArmy();
        else
            enableArmy();
    }

    /**
     * Method that adds a unit at the end of a CArmy.
     */
    public void addUnit(CUnit u) {
        getUnits().add(u);
    }

    /**
     * Method that adds a unit to a CArmy, in a specified position. Called from
     * CPlayer in response to a PL|RPU. See CPlayer.java and PL.java for more
     * info.
     */
    public void addUnit(CUnit u, int position) {
        getUnits().add(position, u);
    }

    /**
     * Method that returns an amriy's legal operations. Used throughout the
     * client to build GUI elements.
     */
    public TreeSet<String> getLegalOperations() {
        return legalOperations;
    }

    /**
     * This method is used to port saved legal ops info to a newly added CArmy,
     * if an army with the same ID previously existed. This allows the server to
     * send updates (lost 1 type, etc) instead of resending all of an army's ops
     * whenever data is resent to the client.
     * 
     * See CPlayer.setArmyData() for usage details.
     */
    protected void setLegalOperations(TreeSet<String> ts) {
        legalOperations = ts;
    }

    /**
     * Client-side duplication of SArmy's getOperationsBV math. If the client,
     * via tha downloaded server config data, knows that Operation Flashpoint
     * style BV adjustments are in use, the HQ calls this method in order to
     * accurately display BV vs. 4 without forcing the server to recalculate BV
     * every time a unit is added to/removed from an army.
     * 
     * See comments in SArmy for more information about how the adjustment is
     * determined, etc.
     */
    /*
     * public int getOperationsBV() { //if not using the operations rules,
     * return a normal undamaged BV. boolean useingOpRules =
     * Boolean.parseBoolean(mwclient.getserverConfigs("UseOperationsRule")); if
     * (!useingOpRules) return this.getBV();
     * 
     * double thisRawSize = this.getRawForceSize();//use getter in case it's 0
     * //get the base force size. should be 4 for IS and 5 for Clans. double
     * opForceRawSize =
     * Double.parseDouble(mwclient.getserverConfigs("BaseForceSize"));
     * 
     * if (opForceRawSize >= thisRawSize) return this.getBV();//this force is
     * smaller. no modification.
     * 
     * //else - calcualte an op BV. //load the base force multiplier from config
     * ... double baseForcePenalty =
     * Double.parseDouble(mwclient.getserverConfigs("BaseForcePenalty"));
     * 
     * //calculate the force size different double forceDifference = thisRawSize -
     * opForceRawSize;
     * 
     * //determine the multipliers (penalty sizes) double baseForceMultiplier =
     * forceDifference * baseForcePenalty; double rawForceMultiplier =
     * forceDifference/opForceRawSize;
     * 
     * //determine which multiplier is lower, and make it the final multiplier
     * double finalMultiplier = 0; if (baseForceMultiplier < rawForceMultiplier)
     * finalMultiplier = baseForceMultiplier; else finalMultiplier =
     * rawForceMultiplier;
     * 
     * finalMultiplier += 1;//make a proper multipler. eg - 1.08 to increase BV
     * by 8% return (int)(this.getBV()*finalMultiplier);
     * 
     * }//end getOperationsBV
     */

    /**
     * @return returns the raw force size (Force Mod Rule)
     */
    public float getRawForceSize() {

        // dont recalculate if it isnt necessary
        if (rawForceSize != 0)
            return rawForceSize;

        // no break, generate a raw force size
        for (Unit u : this.getUnits()) {
            if (u.getType() == Unit.INFANTRY)
                rawForceSize += Float.parseFloat(mwclient.getserverConfigs("InfantryOperationsBVMod"));
            else if (u.getType() == Unit.VEHICLE)
                rawForceSize += Float.parseFloat(mwclient.getserverConfigs("VehicleOperationsBVMod"));
            else if (u.getType() == Unit.BATTLEARMOR)
                rawForceSize += Float.parseFloat(mwclient.getserverConfigs("BAOperationsBVMod"));
            else if (u.getType() == Unit.AERO)
                rawForceSize += Float.parseFloat(mwclient.getserverConfigs("AeroOperationsBVMod"));
            else if (u.getType() == Unit.PROTOMEK)
                rawForceSize += Float.parseFloat(mwclient.getserverConfigs("ProtoOperationsBVMod"));
            else
                // all other allowed types have a 1.0 weight
                rawForceSize += Float.parseFloat(mwclient.getserverConfigs("MekOperationsBVMod"));
        }

        return rawForceSize;
    }// end getRawForceSize()

    /**
     * @param rfs -
     *            the forcesize to set (Operations Rule)
     */
    public void setRawForceSize(float rfs) {
        rawForceSize = rfs;
    }

    public double forceSizeModifier(double opposingForceSize) {

        /*
         * double myForceSize = 0; double mekSize =
         * Double.parseDouble(mwclient.getserverConfigs("MekOperationsBVMod"));
         * double veeSize =
         * Double.parseDouble(mwclient.getserverConfigs("VehicleOperationsBVMod"));
         * double baSize =
         * Double.parseDouble(mwclient.getserverConfigs("BAOperationsBVMod"));
         * double protoSize =
         * Double.parseDouble(mwclient.getserverConfigs("ProtoOperationsBVMod"));
         * double infSize =
         * Double.parseDouble(mwclient.getserverConfigs("InfantryOperationsBVMod"));
         * 
         * for ( Unit unit : this.getUnits() ){
         * 
         * switch(unit.getType()){ case Unit.MEK: myForceSize += mekSize; break;
         * case Unit.VEHICLE: myForceSize += veeSize; break; case
         * Unit.BATTLEARMOR: myForceSize += baSize; break; case Unit.PROTOMEK:
         * myForceSize += protoSize; break; case Unit.INFANTRY: myForceSize +=
         * infSize; break; default : myForceSize += 1; break; } }
         * 
         * if ( myForceSize > opposingForceSize ) return
         * ((opposingForceSize/myForceSize)+(myForceSize/opposingForceSize))-1;
         * return 1.0;
         */

        double myForceSize = 0;

        this.setRawForceSize(0);
        myForceSize = this.getRawForceSize();

        if (myForceSize > opposingForceSize)
            return ((opposingForceSize / myForceSize) + (myForceSize / opposingForceSize)) - 1;
        return 1.0;

    }

    public float getTotalTonnage() {

        float totalTonnage = 0;

        for (Unit unit : this.getUnits())
            totalTonnage += ((CUnit) unit).getEntity().getWeight();
        return totalTonnage;
    }

    public int getAverageWalk() {

        int walk = 0;

        if (this.getUnits().size() < 1)
            return 0;

        for (Unit unit : this.getUnits()) {
            CUnit en = (CUnit) unit;

            walk += en.getEntity().getWalkMP();
        }

        walk /= this.getUnits().size();

        return walk;
    }

    public int getAverageJump() {

        int walk = 0;

        if (this.getUnits().size() < 1)
            return 0;

        for (Unit unit : this.getUnits()) {
            CUnit en = (CUnit) unit;

            walk += en.getEntity().getJumpMP();
        }

        walk /= this.getUnits().size();

        return walk;
    }
    
    public String getSkillInfoForDisplay() {
    	if (this.getUnits().size() < 1) {
    		return " ";
    	}
    	
    	String avgSkills = "0.0";
    	String avgGunnery = "0.0";
    	String avgPiloting = "0.0";
    	int maxSkill = 0;
    	int maxGunnery = 0;
    	int maxPiloting = 0;
    	int minSkill = 99;
    	int minGunnery = 99;
    	int minPiloting = 99;
    	int numunits = 0;
    	int totalGunnery = 0;
    	int totalPiloting = 0;
    	StringBuilder toReturn = new StringBuilder();
    	for (Unit un : this.getUnits()) {
    		CUnit unit = (CUnit) un;
    		int gunnery = unit.getPilot().getGunnery();
    		int piloting = unit.getPilot().getPiloting();
    		maxSkill = Math.max(maxSkill, (gunnery + piloting));
    		maxGunnery = Math.max(maxGunnery, gunnery);
    		maxPiloting = Math.max(maxPiloting, piloting);
    		minSkill = Math.min(minSkill, (gunnery + piloting));
    		minGunnery = Math.min(minGunnery, gunnery);
    		minPiloting = Math.min(minPiloting, piloting);
    		totalGunnery += gunnery;
    		totalPiloting += piloting;
    		numunits++;
    	}
    	// Need to use a DecimalFormat so we don't get just whole integer averages
    	
    	double avgS = (double) (totalGunnery + totalPiloting) / (double) numunits;
    	double avgG = (double) (totalGunnery) / (double) numunits;
    	double avgP = (double) (totalPiloting) / (double) numunits;
    	DecimalFormat twoDForm = (DecimalFormat)NumberFormat.getNumberInstance();
    	twoDForm.applyPattern("0.00");
    	
    	avgSkills = twoDForm.format(avgS);
    	avgGunnery = twoDForm.format(avgG);
    	avgPiloting = twoDForm.format(avgP);
    	
    	
    	toReturn.append("<html><table><tr><td colspan=4>Skillsums</td></tr>");
    	toReturn.append("<tr><td>&nbsp;</td><td>Total</td><td>Gunnery</td><td>Piloting</td></tr>");
    	toReturn.append("<tr><td>Average:</td><td>" + avgSkills + "</td><td>" + avgGunnery + "</td><td>" + avgPiloting + "</td></tr>");
    	toReturn.append("<tr><td>Maximum:</td><td>" + maxSkill + "</td><td>" + maxGunnery + "</td><td>" + maxPiloting + "</td></tr>");
    	toReturn.append("<tr><td>Minimum:</td><td>" + minSkill + "</td><td>" + minGunnery + "</td><td>" + minPiloting + "</td></tr>");
    	toReturn.append("</table></html>");
    	return toReturn.toString();
    }

}