/*
 * MekWars - Copyright (C) 2004 
 * 
 * Derived from MegaMekNET (http://www.sourceforge.net/projects/megameknet)
 * Original author Helge Richter (McWizard)
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 */

package client.gui;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusListener;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeListener;
import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;

import javax.swing.BoxLayout;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JSeparator;
import javax.swing.event.MenuKeyListener;

import client.MWClient;
import client.campaign.CArmy;
import client.gui.dialog.ArmyViewerDialog;
import client.gui.dialog.PlanetNameDialog;
import client.gui.dialog.PlayerNameDialog;
import common.House;
import common.Planet;
import common.util.MWLogger;

/**
 * Create an "Attack" menu. Used in Map, CMainFramge, etc. to generate
 * menus which show a player's currently available operation options.
 * 
 * Unlike the old Task's dynamic menus, this is an actual class/object,
 * not a static method which returns a contructed menu. Also allows for
 * clearing/updating.
 */

public class AttackMenu extends JMenu implements ActionListener {
	
	
	/**
     * 
     */
    private static final long serialVersionUID = 7420602115238025725L;
    //VARS
	private MWClient mwclient;
	private int armyID;
	private String planetName;
	
	//Statics 
	private static int OPRANGE = 0;
	private static int OPCOLOR = 1;
	//private static int OPLONG = 2;
	private static int OPFACINFO = 3;
	private static int OPHOMEINFO = 4;
	private static int OPLAUNCHON = 5;
	private static int OPLAUNCHFROM = 6;
	private static int OPMINOWN = 7;
	private static int OPMAXOWN = 8;
	private static int OPLEGALDEFENDERS = 9;
	private static int OPALLOWEDPLANETFLAGS = 10;
	private static int OPDISALLOWEDPLANETFLAGS = 11;
	private static int OPAFR = 12;
	private static int OPACTIVE = 13;
	private static int OPACCESSLEVEL = 14;
	//private static int OPMINOWNIBD = 15;	//Baruk 2015-11-7 code to grab value in case it is needed by this .java some other time
	
	//CONSTRUCTOR
	public AttackMenu(MWClient mwclient, int armyID, String planetName) {
		super("Attack");
		this.mwclient = mwclient;
		this.armyID = armyID;
		this.planetName = planetName;
	}
	
	//METHODS
	/*
	 * Most important method in the AttackMenu class. Rebuilds all of the
	 * JMenuItems in the menu by getting army and ops data from the client.
	 */
	public void updateMenuItems(boolean fullMenu) {
		
		//clear old items from this menu
		this.removeAll();
		TreeMap<String,String[]> allOps = mwclient.getAllOps();
		
		/*
		 * Army ID will be < 0 if the attack menu is being
		 * generated by the MainFrame (Game menu) or the Map.
		 * 
		 * The map will pass a planet name, in which case ops
		 * should be filtered by range/factory eligibility, etc.
		 */
		if (armyID < 0) {
			
			/*
			 * Cross reference available ShortOperations for CArmies with
			 * complete OpList.txt streamed from the server. Filter out
			 * out of range/factory ineligible operations if possible.
			 */
			TreeSet<String> allEligibles = new TreeSet<String>();
			
			//no planet name. let the player select from all possible
			//choices, and his planet lists will be limted to valid
			//targets for the selected operation by PlanetNameDialog.
			if (planetName == null || planetName.trim().equals("") || planetName.equals("-1")) {
				for (CArmy currA : mwclient.getPlayer().getArmies())
					allEligibles.addAll(currA.getLegalOperations());
			}
			
			//else, filter out ops which can't reach/target the world
			else {
				
				//load the planet in question
				Planet tp = mwclient.getData().getPlanetByName(planetName);
				
				//save the players house ID, which will be referenced frequently
				int houseID = mwclient.getPlayer().getHouseFightingFor().getId();
				
				//Sub Faction Access Level;
				int accessLevel = mwclient.getPlayer().getSubFactionAccess();
				
				//put all elibibles into a temporary tree. this weeds out
				//duplicate entries and saves some loops through the planets.
				TreeSet<String> tempEligibles = new TreeSet<String>();
				for (CArmy currA : mwclient.getPlayer().getArmies())
					tempEligibles.addAll(currA.getLegalOperations());
				
				//loop through all armies and eligibles
				for (String currOpName : tempEligibles) {
					
					String[] opProps = mwclient.getAllOps().get(currOpName);
					
					//load relevant properties, and the players house ID
					double range = Double.parseDouble(opProps[AttackMenu.OPRANGE]);
					String facInfo = opProps[AttackMenu.OPFACINFO];
                    String homeInfo = opProps[AttackMenu.OPHOMEINFO];
					int launchOn = Integer.parseInt(opProps[AttackMenu.OPLAUNCHON]);
					int launchFrom = Integer.parseInt(opProps[AttackMenu.OPLAUNCHFROM]);
					double minOwn = Double.parseDouble(opProps[AttackMenu.OPMINOWN]);
					double maxOwn = Double.parseDouble(opProps[AttackMenu.OPMAXOWN]);
					String legalDefenders = opProps[AttackMenu.OPLEGALDEFENDERS];
					String allowPlanetFlags = opProps[AttackMenu.OPALLOWEDPLANETFLAGS]+"^";
                    String disallowPlanetFlags = opProps[AttackMenu.OPDISALLOWEDPLANETFLAGS]+"^";
                    boolean reserveOnly = Boolean.parseBoolean(opProps[AttackMenu.OPAFR]);
                    int minAccessLevel = Integer.parseInt(opProps[AttackMenu.OPACCESSLEVEL]);
                    //boolean minOwnIBD = Boolean.parseBoolean(opProps[AttackMenu.OPMINOWNIBD]);  //Baruk 2015-11-7  code to grab value in case it is needed by this .java some other time  
                    
                    //Your sub faction is not allowed to use this!
                    if ( accessLevel < minAccessLevel)
                    	continue;
                    
					//only check for a legal defender limits if necessary
					if (!legalDefenders.startsWith("allFactions")) {
						
						TreeMap<String,Object> legalDefTree = new TreeMap<String,Object>();
						StringTokenizer legalDefTokenizer = new StringTokenizer(legalDefenders, "$");
						while (legalDefTokenizer.hasMoreTokens())
							legalDefTree.put(legalDefTokenizer.nextToken(),null);
						
						boolean foundDefender = false;
						for (House currH : tp.getInfluence().getHouses()) {
							if (legalDefTree.containsKey(currH.getName())){
								foundDefender = true;
								break;
							}
						}
						
						if (!foundDefender)
							continue;
					}
					
					//check the factory requirements
					if (tp.getFactoryCount() > 0 && facInfo.equals("none"))
						continue;
					else if (tp.getFactoryCount() < 1 && facInfo.equals("only"))
						continue;
					
					//check homeworld requirements
                    if (tp.isHomeWorld() && homeInfo.equals("none"))
                        continue;
                    else if (!tp.isHomeWorld() && homeInfo.equals("only"))
                        continue;
                    
                    // convert minOwn and maxOwn to a percentage
                    // wildj79 (James Allred) 2015-09-30
                    minOwn *= tp.getConquestPoints()/100.0D;   //Baruk 2015-11-7 modified to include planet CP in formula
                    maxOwn *= tp.getConquestPoints()/100.0D;   //Baruk 2015-11-7 modified to include planet CP in formula
                    
					//check the ownership requirements
					if (tp.getInfluence().getInfluence(houseID) < minOwn)
						continue;
					if (tp.getInfluence().getInfluence(houseID) > maxOwn)
						continue;
					
					//check on-target launch
					if (tp.getInfluence().getInfluence(houseID) >= launchOn) {
						allEligibles.add(currOpName);
						continue;
					}
                    
                    //Check for allowed planet flags. the planet most have these flags.
                    if ( allowPlanetFlags.length() > 0 ){
                        //MWLogger.errLog(currOpName+" AllowPlanetFlags: "+allowPlanetFlags);
                        boolean allowOp = true;
                        StringTokenizer st = new StringTokenizer(allowPlanetFlags,"^");
                        while ( st.hasMoreTokens() ){
                            String key = st.nextToken();
                            
                            if ( key.trim().length() < 1 )
                                continue;
                            if ( !tp.getPlanetFlags().containsKey(key) ){
                                MWLogger.errLog(tp.getName()+" does not have flag: "+key);
                                allowOp = false;
                                break;
                            }
                        }
                        if ( !allowOp )
                            continue;
                    }
                    
                    //AFR games do not show up in the AttackMenu/Star Map Menu/HQ
                    if ( reserveOnly )
                    	continue;
                    
                    //Check for disallowed planet flags. If the planet has one of these flags
                    // The planet will not be allowed.
                    if ( disallowPlanetFlags.length() > 0){
                        //MWLogger.errLog(currOpName+" DisallowPlanetFlags: "+disallowPlanetFlags);
                        
                        boolean allowOp = true;
                        StringTokenizer st = new StringTokenizer(disallowPlanetFlags,"^");
                        while ( st.hasMoreTokens() ){
                            String key = st.nextToken();
                            
                            if ( key.trim().length() < 1 )
                                continue;
                            if ( tp.getPlanetFlags().containsKey(key)){
                                allowOp = false;
                                MWLogger.errLog(tp.getName()+" has flag: "+key);
                                break;
                            }
                        }
                        if ( !allowOp )
                            continue;
                    }

					//cant launch on world. see if the operation can be started
					//from a planet the player's house currently owns.
					for (Planet currP : mwclient.getData().getAllPlanets()) {
						
						//check to see if operation can reach target world from currP
						if (currP.getInfluence().getInfluence(houseID) >= launchFrom) {
							double tdist = currP.getPosition().distanceSq(tp.getPosition());
							
							if (tdist <= range) {
								allEligibles.add(currOpName);
								break;
							}
						}
						
					}//end while(still looking for launchpoints)
					
				}//end for(all ops in tempEligibles)
			}//end else(need to filter for range and factories)
			
			if (allEligibles.size() <= 0) {
				JMenuItem filler = new JMenuItem("None");
				this.add(filler);
			}
			
			for (String currName : allEligibles) {
				
				if (!allOps.containsKey(currName)) {
					
					mwclient.updateOpData(false);
					
					if (!allOps.containsKey(currName)) {
						MWLogger.errLog("Error in updateMenuItems(): no _" + currName + "_ in allOps.");
						
						StringBuilder allOpsList = new StringBuilder("allOps contains: ");
						for(String currO : allOps.keySet())
							allOpsList.append(currO + " ");
						MWLogger.errLog(allOpsList.toString());
						
						//don't want to stop building because of one bad apple - continue to next element.
		                continue;
					}
				}
				
				String[] settings = allOps.get(currName);
				String color = settings[AttackMenu.OPCOLOR];
				//String hasLong = settings[2];//int, not a boolean
	            
				//we don't care about range here, but we do
				//want to take notice of longs and colours.
				String menuItemName = "";
				if (!fullMenu)
					menuItemName = "<html><font color=" + color + ">" + currName+"</font></html>";
				else
					menuItemName  = " - " + currName;
				
				//if (hasLong.equals("1"))
				//	menuItemName += "[L]</font>";
				//else
				//	menuItemName += "</font>";
				
				JMenuItem currItem = new JMenuItem(menuItemName);
				currItem.addActionListener(this);
				currItem.setActionCommand(currName);
				this.add(currItem);
			}
			
		} 
		
		/*
		 * Else, this menu is being generated by the CHQPanel
		 * when a player right clicks on an army. Show only
		 * the attacks which the army in question may make.
		 */
		else {
			
			CArmy clickArmy = mwclient.getPlayer().getArmy(armyID);
			
            if ( clickArmy != null ){
            
    			if (clickArmy.getLegalOperations().size() <= 0) {
    				JMenuItem filler = new JMenuItem("None");
    				this.add(filler);
    			}
    			
    			for (String currName : clickArmy.getLegalOperations()) {
    				
    				if (!allOps.containsKey(currName)) {
    					MWLogger.errLog("Error in updateMenuItems(): no _" + currName + "_ in allOps.");
    					
    					String allOpsList = "allOps contains: ";
    					for(String currO : allOps.keySet())
    						allOpsList += currO + " ";
    					MWLogger.errLog(allOpsList);
    					
    	                //don't stop building the list just because of one bad apple...
    	                continue;
    				}
    				


    				String[] settings = allOps.get(currName);
    				/*
    	             * Filter out games that are reserve-only. Attack menus in HQ, CMainFrame and
    	             * on the map may only be used to start games when a player is active, so 
    	             */
   	            	if (Boolean.parseBoolean(settings[AttackMenu.OPAFR]))//12 is reserve only
   	            		continue;

   	            	String color = settings[AttackMenu.OPCOLOR];
    				//String hasLong = settings[2];//int, not a boolean
    	            
    				//we don't care about range here, but we do
    				//want to take notice of longs and colours.
    				String menuItemName = "";
    	            if (!fullMenu)
    	                menuItemName = "<html><font color=" + color + ">" + currName+"</font></html>";
    	        	else
    					menuItemName  = " - " + currName;
    	            
    	            //if (hasLong.equals("1"))
    				//	menuItemName += "[L]</font>";
    				//else
    				//	menuItemName += "</font>";
    				
    				JMenuItem currItem = new JMenuItem(menuItemName);
    				currItem.addActionListener(this);
    				currItem.setActionCommand(currName);
    				this.add(currItem);
    			}
            }
		}
		
		/*
		 * TODO: Sort the JMenuItems by colour, then by name. This
		 *       would allow server operators to group similar games
		 *       together.
		 */
		
		/*
		 * If <code>fillMenu</code> is true, rename to
		 * "GAME" menu and cram in some Extra things.
		 */
		if (fullMenu) {
			
			this.setText("Games");
			this.setMnemonic('G');
            
			JMenuItem toAdd = new JMenuItem("Attacks:");
			MouseListener[] mouse = toAdd.getMouseListeners();
			FocusListener[] focus = toAdd.getFocusListeners();
			MenuKeyListener[] menukey = toAdd.getMenuKeyListeners();
			PropertyChangeListener[]property = toAdd.getPropertyChangeListeners();
			
			for(int i=0; i<mouse.length; i++)
				toAdd.removeMouseListener(mouse[i]);
			for(int i=0; i < focus.length; i++)
				toAdd.removeFocusListener(focus[i]);
			for(int i=0; i < menukey.length; i++)
				toAdd.removeFocusListener(focus[i]);
			for(int i=0; i < property.length; i++)
				toAdd.removePropertyChangeListener(property[i]);
			
			this.add(toAdd, 0);
			
            if ( Boolean.parseBoolean(mwclient.getserverConfigs("AllowAttackFromReserve")) 
                    && mwclient.getMyStatus() == MWClient.STATUS_RESERVE){
                this.add(new JSeparator());
                toAdd = new JMenuItem("Attack From Reserve");
                toAdd.addActionListener(this);
                toAdd.setActionCommand("cmdAttackFromReserve");
                this.add(toAdd);
            }
            
			this.add(new JSeparator());
			toAdd = new JMenuItem("Check Access");
			toAdd.addActionListener(this);
			toAdd.setActionCommand("cmdCheckAccess");
			this.add(toAdd);

            toAdd = new JMenuItem("Games Status");
            toAdd.addActionListener(this);
            toAdd.setActionCommand("cmdGamesStatus");
            toAdd.setMnemonic('G');
            this.add(toAdd);

			if (mwclient.getMyStatus() >= MWClient.STATUS_ACTIVE) {
				toAdd = new JMenuItem("Cancel Game");
				toAdd.addActionListener(this);
				toAdd.setActionCommand("cmdCancelGames");
				this.add(toAdd);
			}
			
		}
	}
	
	/**
	 * The actionCommand has to be of the following structure:
	 * 
	 * aid|pid 
	 * *or*
	 * aid|pid|arg0|arg1|arg2...
	 * 
	 * "aid" is the ArmyID to use. If "-1", choice will be given.
	 * "pid" is the PlanetID to attack. If "-1", menu will open.
	 * 
	 * cmd is the command and one of those:
	 * 
	 * if arg0 == "multi"
	 * arg1: maxattackers
	 * arg2: minattackers
	 * arg3: maxdefenders
	 * arg4: mindefenders
	 * 
	 * @see java.awt.event.ActionListener#actionPerformed
	 */
	public void actionPerformed(ActionEvent e) {
		
		String name = e.getActionCommand();
		//private String armyID;
		//private String planetID;
		
        if ( name.equals("cmdCancelGames") ){
            mwclient.sendChat(MWClient.CAMPAIGN_PREFIX + "c terminate");
            return;
        }
        
        /*
         * Check access is hacky and duplicative in some ways ...
         */
        if (name.equals("cmdCheckAccess")) {
        	
        	//if the player has no armies, tell him to make some ... *sigh*
        	if (mwclient.getPlayer().getArmies().size() <= 0) {
            	String toUser = "CH|CLIENT: It's impossible to check legality when you have no armies.";
    			mwclient.doParseDataInput(toUser);
    			return;
            } 
        	
        	//first, pick an army
        	TreeSet<String> names = new TreeSet<String>();
			for (CArmy currArmy : mwclient.getPlayer().getArmies())
				names.add("#" + currArmy.getID()+ " - BV: "+ currArmy.getBV());
			
			JComboBox armyCombo = new JComboBox(names.toArray());
			armyCombo.setEditable(false);
			
			JComboBox attackCombo = new JComboBox(mwclient.getAllOps().keySet().toArray());
			attackCombo.setEditable(false);
			
			JPanel holderPanel = new JPanel();
			holderPanel.setLayout(new BoxLayout(holderPanel, BoxLayout.Y_AXIS));
			holderPanel.add(armyCombo);
			holderPanel.add(attackCombo);
			            
            JOptionPane jop = new JOptionPane(holderPanel, JOptionPane.QUESTION_MESSAGE,JOptionPane.OK_CANCEL_OPTION);
			JDialog dlg = jop.createDialog(mwclient.getMainFrame(), "Select army and attack type.");
			armyCombo.grabFocus();
			armyCombo.getEditor().selectAll();
			dlg.setVisible(true);

            if ( (Integer)jop.getValue()  == JOptionPane.CANCEL_OPTION )
                return;
            
			String attackName = (String)attackCombo.getSelectedItem();
            String armyName = (String)armyCombo.getSelectedItem();
            armyID = Integer.parseInt(armyName.substring(1,armyName.indexOf(" ")).trim());

			mwclient.sendChat(MWClient.CAMPAIGN_PREFIX + "c checkarmyeligibility#" + armyID + "#" + attackName);
			return;
        }
        
        /*
         * Game status
         */
        if ( name.equals("cmdGamesStatus") ){
            mwclient.sendChat(MWClient.CAMPAIGN_PREFIX + "c games");
            return;
        }
        
        /*
         * Allows players to attack from reserve
         */
        if (name.equals("cmdAttackFromReserve")) {
        
            String planet = "";
            String target = "";
            String Op = "";
            //int armyID = -1;
            TreeSet<String> allEligibles = new TreeSet<String>();

            for (CArmy currA : mwclient.getPlayer().getArmies())
                allEligibles.addAll(currA.getLegalOperations());
            
            /*
             * Filter out games that are active-only
             */
            Iterator<String> i = allEligibles.iterator();
            while (i.hasNext()) {
            	String[] currProperties = mwclient.getAllOps().get(i.next());
            	if (Boolean.parseBoolean(currProperties[AttackMenu.OPACTIVE]))//13 is active only
            		i.remove();
            }

            JComboBox attackCombo = new JComboBox(allEligibles.toArray());
            attackCombo.setEditable(false);
            JOptionPane jop = new JOptionPane(attackCombo, JOptionPane.QUESTION_MESSAGE,JOptionPane.OK_CANCEL_OPTION);
            JDialog dlg = jop.createDialog(mwclient.getMainFrame(), "Select an operation.");
            dlg.setVisible(true);
            
            if ( (Integer)jop.getValue() == JOptionPane.CANCEL_OPTION )
                return; 
            
            Op = (String)attackCombo.getSelectedItem();
            
            String[] opProperties = mwclient.getAllOps().get(Op);

            PlanetNameDialog planetDialog = new PlanetNameDialog(mwclient,"Choose a planet",opProperties);
            planetDialog.setVisible(true);
            planet = planetDialog.getPlanetName();
            planetDialog.dispose();
            
            if ( planet == null )
                return;
            
            PlayerNameDialog playerDialog = new PlayerNameDialog(mwclient,"Select an opponent",PlayerNameDialog.ANY_PLAYER);
            playerDialog.setVisible(true);
            target = playerDialog.getPlayerName();
            playerDialog.dispose();
            
            if ( target == null )
                return;
            
            new ArmyViewerDialog(mwclient,Op,null,ArmyViewerDialog.AVD_ATTACKFROMRESERVE,planet,target,-1,-1);
            return;
        }
        
        /*
         * Terminating is always a viable option; however,
         * anything else is a nonstarter unless the player
         * is actually active.
         */
        if (mwclient.getMyStatus() < MWClient.STATUS_ACTIVE) {
        	String toUser = "CH|CLIENT: You must be active in order to initiate standard attacks.";
			mwclient.doParseDataInput(toUser);
			return;
        } else if (mwclient.getMyStatus() == MWClient.STATUS_FIGHTING) {
        	String toUser = "CH|CLIENT: You may not initiate an attack while you are in a game.";
			mwclient.doParseDataInput(toUser);
			return;
        }
            
		//Check the planet name - if a number, open the menu.
		if (planetName.equals("-1")) {
			
			//load properties to send to the planet selection dialog
			String[] opProperties = mwclient.getAllOps().get(name);
			
			PlanetNameDialog planetdialog = new PlanetNameDialog(mwclient,"Select a planet to attack.", opProperties);
			planetdialog.setVisible(true);
			planetName = planetdialog.getPlanetName();
			planetdialog.dispose();
			
			if (planetName == null || planetName.trim().length() == 0)
				return;
		}
		
		//check the army name/id
		if (armyID < 0) {
			
            new ArmyViewerDialog(mwclient,name,null,ArmyViewerDialog.AVD_ATTACK,planetName,null,-1,-1);
            /*ArmyViewerDialog armyViewer = new ArmyViewerDialog(mwclient,name,null);
            //armyViewer.setVisible(true);
            armyID = armyViewer.getSelectedArmyID();
            armyViewer.dispose();

			if ( armyID < 0 )
				return;*/
		}
        else
            mwclient.sendChat(MWClient.CAMPAIGN_PREFIX + "c attack#" + name + "#" + armyID + "#" + planetName);
	}
	
}
